# 文件加密解密方案



## 过程

1. 最开始考虑使用 [Jetpack Security](https://developer.android.com/jetpack/androidx/releases/security) 来做加解密，考虑到是 Jetpack 组件的一部分，有利于我们遵守官方指定的技术选型和开发流程，有问题也方便解决。

   但在接入后发现几点问题：

   - 1.0.0 版本最低支持的 Android sdk 版本是 23，后来发现 [1.1.0-alpha03](https://developer.android.com/jetpack/androidx/releases/security#security-crypto-1.1.0-alpha03) 版本可以支持最低 21，升级到这个版本，但此版本之后官方久久未更新 1.1.0 的正式版，可能有潜在的不稳定因素。
   - 使用 [1.1.0-alpha03](https://developer.android.com/jetpack/androidx/releases/security#security-crypto-1.1.0-alpha03) 版本过程中发现他提供的部分 Api 依赖的最低 Android sdk 还得是 23，且 R8 的脱糖机制尚未覆盖这些 Api，所以我们可能支持的 Api 21 的设备就无法支持。
   - 使用 Security 加解密测试性能发现很慢，即便是采用了 AES 这种非对称的加密方式依旧很慢，Security 实际是对 [Tink](https://github.com/google/tink) 的包装。

2. 后面在研究 [AmazeFileManager](https://github.com/TeamAmaze/AmazeFileManager) 的加解密过程实现，发现他们采用了 Java 自带的 [Cipher](https://docs.oracle.com/javase/7/docs/api/javax/crypto/Cipher.html) 和 [CipherOutputStream](https://docs.oracle.com/javase/7/docs/api/javax/crypto/CipherOutputStream.html) 等 Api 实现，他们对文件夹加密的处理不是我们想想中加密成一个文件的做法，而是对原文件夹添加后缀之后把内部的各个文件分别加密，显示的时候显示成一个文件而已，调用其他文件管理软件查看相关路径可以佐证这一点。后面我又尝试探索了我自己常用的付费文件管理 [Solid Explorer File Manager](https://play.google.com/store/apps/details?id=pl.solidexplorer2&hl=en_US&gl=US)，他也是采用了类似的处理机制，其他的一些不同下面列举：

   - AFM 的密钥存储在软件自带的数据库内，他在移动加密的文件之后会对数据库内的密钥对应的文件的路径做更新，如果卸载重装 AFM 或者采用其他的文件管理软件移动了 AFM 加密过的文件之后，就无法对该文件解密，道理很简单，因为 AFM 的数据库内找不到当前路径下加密文件对应的密钥了。详细分析过程[在这里](https://github.com/Goooler/AmazeFileManager/pull/2)。
   - SEFM 没有上述的问题，移动文件和卸载重装都可以正常解密，猜测应该是把密钥写在了需要加密的文件内部，不用担心密钥丢失。
   - 还有加解密速度的对比，如果是字数不多的纯文本内容可能两款软件加解密的速度都很快，甚至可以说忽略不计。但换用稍微大一点的文件测试的时候，比如选用了一首 mp3 的歌曲测试，大小约为 13 MB，AFM 加解密都要花费几十秒，况且我的测试机器还是一加 8t 这种配置相对较高的，拖累速度的应该不是硬件短板而是加解密算法；我用 SEFM 测试的话，加解密都很快，几乎一瞬间完成，再换用更大的，超过 100 MB 的文件测试，依旧很快，感觉加解密速度甚至媲美文件复制的速度。

3. 在有了如上的对比之后，我决定采用简单改写文件流的方式尝试加密。我们知道文件类型的识别依赖文件头，也就是文件开头特定的一些字节序列，参见[常见文件文件头](https://zhuanlan.zhihu.com/p/158980459)，如果我们破坏某个文件头，就可能会让读取的软件不知道如何解码，自然就无法识别文件内容了，于是有了以下尝试。

   - 加密：在文件开头插入一段带有密钥消息的字符串的字节序列，为了避免密钥信息和常见的文件头相同，我决定插入的字符串使用 App 包名 + 密钥。后续我在 AFM 内原有代码上做改动，方便测试。例如加密刚刚那个 mp3 文件，给定密钥 `666`，加上原有的包名 `com.amaze.filemanager` 组成了 `666com.amaze.filemanager` 的字符串，把该字符串转 byte[] 之后写入文件头，然后使用音乐播放软件尝试读取内容，发现无法读取。
   - 解密：与加密的操作相反，首先校验加密文件的密钥是否正确，方法是用户输入的密钥+包名转字节数组，然后从加密文件开头读取相同长度的字节数组，然后对比两个数组的内容是否一致，一致表示密钥正确，否则就是错误。如果正确的话，再读取该加密文件剩下的所有字节，写入新文件内，读取新文件内容可以正常播放。为了严谨，我把新生成的 mp3 文件（解密后的）和原来的文件做了哈希比对，发现内容无误。

   以上过程可以[在这里](https://github.com/Goooler/AmazeFileManager/pull/3)查看，最重要的是这种加解密方法速度非常快，几乎等同于文件读写了，毕竟只是在原文件基础上插入了部分自定义字节而已，大小和性能的影响约等于无。



## 结论

最后决定采用的是上述第三种方案，他的优势是加解密速度非常快，缺点也比较明显，加解密不够彻底，甚至只要稍微对加密后的文件改造一下就可以绕过密钥的限制。但是考虑到我们决定在手机上采用加密，无非就是希望一些比较私密的文件不被别人轻易查看到，安全性的重要程度比起速度来说还是需要让步的，毕竟如果是想加密一个视频文件，如果只是为了简单隐藏内容而让用户等待几分钟甚至几十分钟的时间，这是不合情理的。